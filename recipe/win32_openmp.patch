diff --git a/core/base/contourForestsTree/MergeTree.cpp b/core/base/contourForestsTree/MergeTree.cpp
index d2bb6f81..dd716cd2 100644
--- a/core/base/contourForestsTree/MergeTree.cpp
+++ b/core/base/contourForestsTree/MergeTree.cpp
@@ -429,8 +429,8 @@ void MergeTree::parallelUpdateSegmentation(const bool ct) {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for
 #endif
-    for(idSuperArc sa = 0; sa < nbArc; sa++) {
-      SuperArc *superArc = getSuperArc(sa);
+    for(long long int sa = 0; sa < nbArc; sa++) {
+      SuperArc *superArc = getSuperArc(static_cast<idSuperArc>(sa));
       if(!superArc->isVisible())
         continue;
 
@@ -444,15 +444,15 @@ void MergeTree::parallelUpdateSegmentation(const bool ct) {
       sort(segmentation, segmentation + segmSize, compH);
       for(SimplexId i = 0; i < segmSize; i++) {
         const SimplexId &vert = segmentation[i].first;
-        updateCorrespondingArc(vert, sa);
+        updateCorrespondingArc(vert, static_cast<idSuperArc>(sa));
       }
     }
   } else {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for
 #endif
-    for(idSuperArc sa = 0; sa < nbArc; sa++) {
-      SuperArc *superArc = getSuperArc(sa);
+    for(long long int sa = 0; sa < nbArc; sa++) {
+      SuperArc *superArc = getSuperArc(static_cast<idSuperArc>(sa));
       if(!superArc->isVisible())
         continue;
 
@@ -467,7 +467,7 @@ void MergeTree::parallelUpdateSegmentation(const bool ct) {
       for(SimplexId i = 0; i < segmSize; i++) {
         const SimplexId &vert = segmentation[i].first;
         if(!segmentation[i].second) {
-          updateCorrespondingArc(vert, sa);
+          updateCorrespondingArc(vert, static_cast<idSuperArc>(sa));
         }
       }
     }
@@ -488,9 +488,9 @@ void MergeTree::parallelInitNodeValence(const int nbThreadValence) {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(nbThreadValence)
 #endif
-  for(idNode n = 0; n < nbNodes; n++) {
+  for(long int n = 0; n < nbNodes; n++) {
     short downVal = 0, upVal = 0;
-    Node *node = getNode(n);
+    Node *node = getNode(static_cast<idNode>(n));
 
     const auto nbDown = node->getNumberOfDownSuperArcs();
     for(idSuperArc i = 0; i < nbDown; i++) {
diff --git a/core/base/depthImageBasedGeometryApproximation/DepthImageBasedGeometryApproximation.h b/core/base/depthImageBasedGeometryApproximation/DepthImageBasedGeometryApproximation.h
index 89c0e407..df331d0c 100644
--- a/core/base/depthImageBasedGeometryApproximation/DepthImageBasedGeometryApproximation.h
+++ b/core/base/depthImageBasedGeometryApproximation/DepthImageBasedGeometryApproximation.h
@@ -147,7 +147,7 @@ int ttk::DepthImageBasedGeometryApproximation::execute(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t y = 0; y < camResST[1]; y += step) {
+    for(long int y = 0; y < camResST[1]; y += step) {
       double v = ((double)y) * pixelHeightWorld;
       double vTimesUp[3]
         = {v * camUpTrue[0], v * camUpTrue[1], v * camUpTrue[2]};
diff --git a/core/base/ftmTree/FTMTree_MT.h b/core/base/ftmTree/FTMTree_MT.h
index b548eb31..859adca5 100644
--- a/core/base/ftmTree/FTMTree_MT.h
+++ b/core/base/ftmTree/FTMTree_MT.h
@@ -706,7 +706,7 @@ namespace ttk {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_) schedule(static)
 #endif
-        for(typename std::vector<type>::size_type i = 0; i < s; i++) {
+        for(long int i = 0; i < s; i++) {
           (*vect)[i] = val;
         }
       }
diff --git a/core/base/ftrGraph/FTRCommon.h b/core/base/ftrGraph/FTRCommon.h
index 004e8961..3c8e24d0 100644
--- a/core/base/ftrGraph/FTRCommon.h
+++ b/core/base/ftrGraph/FTRCommon.h
@@ -78,7 +78,7 @@ namespace ttk {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for schedule(dynamic)
 #endif
-        for(std::size_t i = 0; i < nbIt; i++) {
+        for(long int i = 0; i < nbIt; i++) {
           vect[i] = elmt;
         }
       }
diff --git a/core/base/meshGraph/MeshGraph.h b/core/base/meshGraph/MeshGraph.h
index 197c38d7..2438e588 100644
--- a/core/base/meshGraph/MeshGraph.h
+++ b/core/base/meshGraph/MeshGraph.h
@@ -209,7 +209,7 @@ int ttk::MeshGraph::execute(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputPoints; i++) {
+    for(long int i = 0; i < nInputPoints; i++) {
       float data[4];
       getInputPointData(i, data);
 
@@ -274,7 +274,7 @@ int ttk::MeshGraph::execute(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t temp = i * 3 + 1;
       size_t aInputIndex = (size_t)inputTopology[temp++];
       size_t bInputIndex = (size_t)inputTopology[temp];
@@ -329,7 +329,7 @@ int ttk::MeshGraph::execute(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t temp = i * 3 + 1;
       topoType aInputIndex = inputTopology[temp++];
       topoType bInputIndex = inputTopology[temp];
@@ -456,7 +456,7 @@ int ttk::MeshGraph::execute2(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputPoints; i++) {
+    for(long int i = 0; i < nInputPoints; i++) {
       float data[4];
       getInputPointData(i, data);
 
@@ -508,7 +508,7 @@ int ttk::MeshGraph::execute2(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t temp = i * 3 + 1;
       size_t n0 = (size_t)inputTopology[temp++];
       size_t n1 = (size_t)inputTopology[temp];
@@ -546,7 +546,7 @@ int ttk::MeshGraph::execute2(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t q = i * 3 + 1;
       topoType in0 = inputTopology[q++] * 2;
       topoType in1 = inputTopology[q] * 2;
@@ -604,7 +604,7 @@ int ttk::MeshGraph::mapInputPointDataToOutputPointData(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputPoints; i++) {
+    for(long int i = 0; i < nInputPoints; i++) {
       size_t q = i * 3;
       // a, a0, a1
       outputPointData[q] = inputPointData[i];
@@ -618,7 +618,7 @@ int ttk::MeshGraph::mapInputPointDataToOutputPointData(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t temp = i * 3 + 1;
       size_t aInputIndex = (size_t)inputTopology[temp++];
       size_t bInputIndex = (size_t)inputTopology[temp];
@@ -654,7 +654,7 @@ int ttk::MeshGraph::mapInputPointDataToOutputPointData(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputPoints; i++) {
+    for(long int i = 0; i < nInputPoints; i++) {
       size_t offset = i * 2;
       auto &v = inputPointData[i];
       outputPointData[offset] = v;
@@ -668,7 +668,7 @@ int ttk::MeshGraph::mapInputPointDataToOutputPointData(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t q = i * 3 + 1;
       topoType c0 = inputTopology[q];
       dataType c0V = inputPointData[c0];
@@ -702,7 +702,7 @@ int ttk::MeshGraph::mapInputCellDataToOutputCellData(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       size_t offset = i * 2;
       outputCellData[offset] = inputCellData[i];
       outputCellData[offset + 1] = inputCellData[i];
@@ -711,7 +711,7 @@ int ttk::MeshGraph::mapInputCellDataToOutputCellData(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-    for(size_t i = 0; i < nInputCells; i++) {
+    for(long int i = 0; i < nInputCells; i++) {
       outputCellData[i] = inputCellData[i];
     }
   }
diff --git a/core/base/morseSmaleQuadrangulation/MorseSmaleQuadrangulation.cpp b/core/base/morseSmaleQuadrangulation/MorseSmaleQuadrangulation.cpp
index 8620e625..a5effd69 100644
--- a/core/base/morseSmaleQuadrangulation/MorseSmaleQuadrangulation.cpp
+++ b/core/base/morseSmaleQuadrangulation/MorseSmaleQuadrangulation.cpp
@@ -673,7 +673,7 @@ int ttk::MorseSmaleQuadrangulation::subdivise() {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-    for(size_t j = 0; j < outputDists.size(); ++j) {
+    for(long int j = 0; j < outputDists.size(); ++j) {
       Dijkstra::shortestPath(midsNearestVertex[j], *triangulation_,
                              outputDists.at(j), std::vector<SimplexId>(), mask);
     }
@@ -684,7 +684,7 @@ int ttk::MorseSmaleQuadrangulation::subdivise() {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-    for(size_t j = 0; j < sum.size(); ++j) {
+    for(long int j = 0; j < sum.size(); ++j) {
       // skip if vertex j not in cell i
       if(morseSeg_[j] != cellId_[i]) {
         continue;
diff --git a/core/base/quadrangulationSubdivision/QuadrangulationSubdivision.cpp b/core/base/quadrangulationSubdivision/QuadrangulationSubdivision.cpp
index 2ca50b0d..255d76d6 100644
--- a/core/base/quadrangulationSubdivision/QuadrangulationSubdivision.cpp
+++ b/core/base/quadrangulationSubdivision/QuadrangulationSubdivision.cpp
@@ -21,7 +21,7 @@ ttk::SimplexId
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < sum.size(); ++i) {
+  for(long int i = 0; i < sum.size(); ++i) {
     float m = vertexDistance_[a][i];
     float n = vertexDistance_[b][i];
     // stay on the shortest path between a and b
@@ -51,7 +51,7 @@ ttk::SimplexId ttk::QuadrangulationSubdivision::findQuadBary(
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < sum.size(); ++i) {
+  for(long int i = 0; i < sum.size(); ++i) {
 
     // skip following computation if too far from any parent quad vertex
     bool skip = std::any_of(
@@ -104,7 +104,7 @@ int ttk::QuadrangulationSubdivision::subdivise() {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < outputPoints_.size(); ++i) {
+  for(long int i = 0; i < outputPoints_.size(); ++i) {
 
     // skip if already computed on a coarser subdivision
     if(vertexDistance_[i].empty()) {
@@ -532,7 +532,7 @@ int ttk::QuadrangulationSubdivision::project(const std::set<size_t> &filtered,
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < outputPoints_.size(); i++) {
+  for(long int i = 0; i < outputPoints_.size(); i++) {
 
     // skip computation if i in filtered
     if(filtered.find(i) != filtered.end()) {
@@ -621,7 +621,7 @@ int ttk::QuadrangulationSubdivision::relax(const std::set<size_t> &filtered) {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < outputPoints_.size(); i++) {
+  for(long int i = 0; i < outputPoints_.size(); i++) {
 
     // skip computation if i in filtered
     if(filtered.find(i) != filtered.end()) {
@@ -694,7 +694,7 @@ void ttk::QuadrangulationSubdivision::quadStatistics() {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < outputQuads_.size(); ++i) {
+  for(long int i = 0; i < outputQuads_.size(); ++i) {
     const auto &q = outputQuads_[i];
     Point pi = outputPoints_[q.i];
     Point pj = outputPoints_[q.j];
@@ -752,7 +752,7 @@ void ttk::QuadrangulationSubdivision::quadStatistics() {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < static_cast<size_t>(vertexNumber_); ++i) {
+  for(long int i = 0; i < static_cast<size_t>(vertexNumber_); ++i) {
     float minDist{std::numeric_limits<float>::infinity()};
     Point p{};
     triangulation_->getVertexPoint(i, p.x, p.y, p.z);
@@ -790,7 +790,7 @@ void ttk::QuadrangulationSubdivision::quadStatistics() {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif // TTK_ENABLE_OPENMP
-  for(size_t i = 0; i < outputPoints_.size(); ++i) {
+  for(long int i = 0; i < outputPoints_.size(); ++i) {
     float maxDist{};
     for(size_t j = 0; j < static_cast<size_t>(vertexNumber_); ++j) {
       Point p{};
diff --git a/core/base/uncertainDataEstimator/UncertainDataEstimator.h b/core/base/uncertainDataEstimator/UncertainDataEstimator.h
index a4c598d6..8a8f7e1c 100644
--- a/core/base/uncertainDataEstimator/UncertainDataEstimator.h
+++ b/core/base/uncertainDataEstimator/UncertainDataEstimator.h
@@ -45,7 +45,7 @@ namespace ttk {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-        for(size_t i = 0; i < numberOfVertices; i++) {
+        for(long int i = 0; i < numberOfVertices; i++) {
           upperBound_[i] = inputData[i];
           lowerBound_[i] = inputData[i];
         }
@@ -53,7 +53,7 @@ namespace ttk {
 #ifdef TTK_ENABLE_OPENMP
 #pragma omp parallel for num_threads(threadNumber_)
 #endif
-        for(size_t i = 0; i < numberOfVertices; i++) {
+        for(long int i = 0; i < numberOfVertices; i++) {
           // Upper Bound
           if(inputData[i] > upperBound_[i]) {
             upperBound_[i] = inputData[i];
